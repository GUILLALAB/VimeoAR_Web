<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>My first three.js app</title>
    <style>
        body {
            margin: 0;
        }
    </style>
</head>

<body>
    <script src="https://threejs.org/build/three.js"></script>
    <script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>
    <script>
        let clickMouse,
  moveMouse,
  raycaster,
  draggableObject;

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 5;

        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);


        const planeGeometry = new THREE.PlaneBufferGeometry(50, 50, 8, 8);
        const planeMaterial = new THREE.MeshPhongMaterial({ color: 0xcccccc });
        const plane = new THREE.Mesh(planeGeometry, planeMaterial);
        plane.rotateX(-Math.PI / 2);
        plane.position.y = -3;
        plane.receiveShadow = true;
        plane.isDraggable = false;
        scene.add(plane);


        const geometry = new THREE.BoxGeometry(2, 2, 2);
        const material = new THREE.MeshPhongMaterial({ color: 0xff00ff });
        const cube = new THREE.Mesh(geometry, material);
        cube.castShadow = true; //default is false
        cube.isDraggable = true;
        scene.add(cube);

        // CAMERA MOVEMENT CONTROLS
  controls = new OrbitControls(camera, renderer.domElement);
  controls.target.set(0, 55, 0);
  controls.enableDamping = true;
  controls.update();

  raycaster = new THREE.Raycaster();
  clickMouse = new THREE.Vector2();
  moveMouse = new THREE.Vector2();

        const dirLight1 = new THREE.DirectionalLight(0xffffff);
        dirLight1.position.set(0, 2, 0);
        dirLight1.castShadow = true;
        scene.add(dirLight1);


        const ambientLight = new THREE.AmbientLight(0x444444);
        scene.add(ambientLight);


     
        const animate = function () {
            controls.update();
            requestAnimationFrame(animate);

            cube.rotation.x += 0.01;
            cube.rotation.y += 0.007;

            renderer.render(scene, camera);
        };

        animate();

        function dragObject() {
  // If 'holding' an object, move the object
  if (draggableObject) {
    raycaster.setFromCamera(moveMouse, camera);
    // `found` is the metadata of the objects, not the objetcs themsevles
    const found = raycaster.intersectObjects(scene.children);
    if (found.length) {
      for (let obj3d of found) {
        if (!obj3d.object.isDraggablee) {
          draggableObject.position.x = obj3d.point.x;
          draggableObject.position.z = obj3d.point.z;
          break;
        }
      }
    }
  }
}

window.addEventListener("click", (event) => {
  // If 'holding' object on-click, set container to <undefined> to 'drop' the object.
  if (draggableObject) {
    draggableObject = undefined;
    return;
  }

  // If NOT 'holding' object on-click, set container to <object> to 'pickup' the object.
  clickMouse.x = (event.clientX / window.innerWidth) * 2 - 1;
  clickMouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
  raycaster.setFromCamera(clickMouse, camera);
  const found = raycaster.intersectObjects(scene.children, true);
  if (found.length && found[0].object.isDraggable) {
    draggableObject = found[0].object;
  }
});

// Constantly updates the mouse location for use in `dragObject()`
window.addEventListener("mousemove", (event) => {
  dragObject(); // Updates the object's postion every time the mouse moves
  moveMouse.x = (event.clientX / window.innerWidth) * 2 - 1;
  moveMouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
});
    </script>
</body>

</html>