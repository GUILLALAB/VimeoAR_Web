<!doctype HTML>
<html>

<head>
  <title>Live AR - Visualize</title>
  <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">

  <style>
    body,
    h1 {
      font-family: "Raleway", sans-serif
    }

    body,
    html {
      height: 100%
    }

    .bgimg {
      background-image: url('113097.jpg');
      min-height: 100%;
      background-position: center;
      background-size: cover;
    }

    p {
      margin: 2px;
      color: white;
    }

    .row {
      display: flex;
    }

    .mirror {
      transform: scaleX(-1);
    }

    input {
      margin-top: 20px;
    }

    #infinite-list {
      /* We need to limit the height and show a scrollbar */
      width: 200px;
      height: 300px;
      overflow: auto;

      /* Optional, only to check that it works with margin/padding */
      margin: 30px;
      padding: 20px;
      border: 5px solid rgb(255, 255, 255);
    }

    /* Optional eye candy below: */
    li {
      padding: 5px;
      list-style-type: none;
      background: white;
    }

    li:hover {
      background: rgb(255, 255, 255);
    }

    .notification {
      background-color: #555;
      color: white;
      text-decoration: none;
      padding: 15px 15px;
      position: absolute;
      bottom: 0;
      margin-bottom: 50px;
      display: inline-block;
      border-radius: 2px;
    }

    .notification:hover {
      background: red;
    }

    .notification .badge {
      position: absolute;
      top: -10px;
      right: -10px;
      padding: 5px 10px;
      border-radius: 50%;
      background: red;
      color: white;
    }
  </style>
</head>
<script src="/js/AgoraRTCSDK-3.0.2.js" type="text/javascript"></script>
<script src="/js/agora-rtm-sdk-1.2.2.js" type="text/javascript"></script>
<link href="https://fonts.googleapis.com/css?family=Heebo:400,700|Oxygen:700" rel="stylesheet">
<script src="https://unpkg.com/scrollreveal@4.0.5/dist/scrollreveal.min.js"></script>
<link rel="stylesheet" type="text/css" href="style_listBroadcast.css" />

<!-- Material Design Lite -->
<link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">
<link rel="stylesheet" href="https://code.getmdl.io/1.1.3/material.orange-indigo.min.css">
<script defer src="https://code.getmdl.io/1.1.3/material.min.js"></script>

<!-- App Styling -->
<link rel="stylesheet"
  href="https://fonts.googleapis.com/css?family=Roboto:regular,bold,italic,thin,light,bolditalic,black,medium&amp;lang=en">

<body style="background-color:black;text-align:center">
  <!-- Navbar -->

  <div class="w3-top">
    <div class="w3-bar w3-black w3-card w3-left-align w3-large">
      <a class="w3-bar-item w3-button w3-hide-medium w3-hide-large w3-right w3-padding-large w3-hover-white w3-large w3-black"
        href="javascript:void(0);" onclick="myFunction()" title="Toggle Navigation Menu"><i class="fa fa-bars"></i></a>
      <div id="user-container">
        <div hidden id="user-pic"></div>
        <div hidden id="user-name"></div>
        <button hidden id="sign-out" class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-color-text--white">
          Sign-out
        </button>
        <button hidden id="sign-in" class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-color-text--white">
          <i class="material-icons"></i>Sign-in
        </button>
      </div>
      <a href="#" class="w3-bar-item w3-button w3-hide-small w3-padding-large w3-hover-white"></a>
    </div>

    <!-- Navbar on small screens -->
    <div id="navDemo" class="w3-bar-block w3-white w3-hide w3-hide-large w3-hide-medium w3-large">
      <a href="#" class="w3-bar-item w3-button w3-padding-large"></a>
    </div>

  </div>



      <input type="text" placeholder="broadcaster channel name" id="myInput">

   
  <div id="messages-card-container" class="mdl-cell mdl-cell--12-col mdl-grid">

    <!-- Messages container -->
    <div id="messages-card"
      class="mdl-card mdl-shadow--0dp mdl-cell mdl-cell--12-col mdl-cell--6-col-tablet mdl-cell--6-col-desktop">
      <div id="messages">
      </div>


    </div>
    <a id="badgeButton" href="#" class="notification">
      <span>Objects</span>
      <span id="object_badge" class="badge"></span>
    </a>
  </div>


  <video id="video" loop crossOrigin="anonymous" webkit-playsinline style="display:none">
    <source id="source" src="video.mp4" type="video/mp4">
  </video>

	<canvas id="c"></canvas>


  <script src="utils.js"></script>


  <script id="vertexShader" type="glsl">

    varying vec2 vUv;
    void main( void ) {
      vUv = uv;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
    }

    </script>


  <script id="fragmentShader" type="glsl">

    uniform vec3 keyColor;
    uniform float similarity;
    uniform float smoothness;
    varying vec2 vUv;
    uniform sampler2D map;
    void main() {

      vec4 videoColor = texture2D(map, vUv);

      float Y1 = 0.299 * keyColor.r + 0.587 * keyColor.g + 0.114 * keyColor.b;
      float Cr1 = keyColor.r - Y1;
      float Cb1 = keyColor.b - Y1;

      float Y2 = 0.299 * videoColor.r + 0.587 * videoColor.g + 0.114 * videoColor.b;
      float Cr2 = videoColor.r - Y2;
      float Cb2 = videoColor.b - Y2;

      float blend = smoothstep(similarity, similarity + smoothness, distance(vec2(Cr2, Cb2), vec2(Cr1, Cb1)));
      gl_FragColor = vec4(videoColor.rgb, videoColor.a * blend);
    }

    </script>


  <script type="module">
   		import * as THREE from './jsm/three.module.js';
		import { OrbitControls } from 'https://threejsfundamentals.org/threejs/resources/threejs/r122/examples/jsm/controls/OrbitControls.js';
		import { GLTFLoader } from './jsm/GLTFLoader.js';

    import { FBXLoader } from './jsm/FBXLoader.js';

    import { LoadingBar } from './jsm/LoadingBar.js';
    import { ARButton } from './jsm/webxr/ARButton.js';
    import { Ads, loadAds, loadObject, Object, Broadcaster } from './js/index_greenscreen.js';

    let container;
    let camera, scene, renderer, source;
    let controller;

    let clickMouse,
			moveMouse,
			raycaster,
			draggableObject;
      var importedObject = null;
		var importedObjectposition;
		var video = null;
    let reticle,controls, canvas;
    var cube, texture, material;
    var isset = 0;
    let videoTexture;
    let videoImageContext;
    let hitTestSource = null;
    let hitTestSourceRequested = false;
    var client = null;
    var ads = null;
    var mesh = null;
    var tex = null;
    var chair = null;
    var streamCount;
    var channelName;
    var agoraAppId;
    var rtmClient = null;
    var offscreenCanvas;
    var videoElement;
    var transparentCanvas;
    var callBtnTransparent;
    var videoEnabled;
    var transparencyEnabled;
    var offscreenCanvas;
    let height, width;
    let videoDevices = [];
    var object_badge = 0;
    var object_badges;
    var badgeButton;
    // canvas green screen controls
    const gFloorRange = 105;
    const rbCeilingRange = 80;
    const FRAME_RATE = 25;
    let videoWidth = 320;
    let videoHeight = 240;
    var assetsPath;
    // Safari & Firefox don't support OffscreenCanvas
    var mixer = null;

    var loadingBar;
    let segmentedCanvas;
    var clock;

    init();
    InitClient();

    function myFunction() {
      video.play();
    }

    function PlayVideo(srcVideo) {
      video.pause();
      source.src = srcVideo;
      video.load();
    }

    function StopVideo() {
      document.getElementById('video').pause();
    }



    function init() {

      assetsPath = './ar-shop/';
      loadingBar = new LoadingBar();
      loadingBar.visible = false;

      agoraAppId = 'e76fbfaa876b4c68a5d92d92aa6ad3b1'; // insert Agora AppID here
      channelName = '';
      streamCount = 0;
      client = AgoraRTC.createClient({ mode: 'live', codec: 'vp8' }); // vp8 to work across mobile devices
      rtmClient = AgoraRTM.createInstance(agoraAppId);
      AgoraRTC.Logger.setLogLevel(AgoraRTC.Logger.DEBUG);


      canvas = document.getElementById("c");

      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.z = 100;

      renderer = new THREE.WebGLRenderer({ canvas: canvas });
		renderer.setSize(window.innerWidth, window.innerHeight);
		renderer.shadowMap.enabled = true;

      const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1);
      light.position.set(0.5, 1, 0.25);
      scene.add(light);


		const planeGeometry = new THREE.PlaneBufferGeometry(50, 40, 8, 8);
		const planeMaterial = new THREE.MeshPhongMaterial({ color: 0x222222 });
		const plane = new THREE.Mesh(planeGeometry, planeMaterial);
		plane.rotateX(-Math.PI / 2);
		plane.position.y = -3;
		plane.receiveShadow = true;
		plane.isDraggable = false;
		scene.add(plane);

    controls = new OrbitControls(camera, renderer.domElement);
		controls.enableDamping = true;
		controls.update();

		raycaster = new THREE.Raycaster();
		clickMouse = new THREE.Vector2();
		moveMouse = new THREE.Vector2();

    const dirLight1 = new THREE.DirectionalLight(0xffffff);
		dirLight1.position.set(0, 2, 0);
		dirLight1.castShadow = true;
		scene.add(dirLight1);


		const ambientLight = new THREE.AmbientLight(0x444444);
		scene.add(ambientLight);

      clock = new THREE.Clock();
      loadAds();


      object_badges = document.getElementById('object_badge');
      object_badges.textContent = object_badge;
      badgeButton = document.getElementById('badgeButton');

      badgeButton.addEventListener("click", function (e) {
        setAds3DModel(Broadcaster.objecturl);
      });


      document.addEventListener("buttonclick", function (e) {
        // alert(e.detail);
        document.getElementById("myInput").value = e.detail.channel;
        channelName = e.detail.channel;
        Timer();
        object_badge = 0;
        object_badges.textContent = object_badge;
        loadObject(e.detail.id);
        initAgora(channelName);
      });

      document.addEventListener("models", function (e) {
        // alert(e.detail);
        Ads.link = e.detail;
        if (Ads.link != null && Ads.link.includes("png")) {
          const geo = new THREE.PlaneBufferGeometry(0.7, 0.7); // width, height, no depth for plane
          //load the texture
          var tex = new THREE.TextureLoader().load(Ads.link);

          //set the texture as map parameter of the material
          var mat = new THREE.MeshBasicMaterial({ map: tex });
          ads = new THREE.Mesh(geo, mat);

          scene.add(ads);
        } else if (Ads.link != null && Ads.link.includes("glb")) {
          setAds3DModel(Ads.link);
        }
      });

      document.addEventListener("broadcastmodel", function (e) {
        // alert(e.detail);
        Broadcaster.objecturl = e.detail;
        if (Broadcaster.objecturl != null) {
          object_badge = (object_badge + 1);
          object_badges.textContent = object_badge;
        }
      });

      //


      //
      const animate = function () {
			controls.update();

			// cube.rotation.x += 0.01;
			// cube.rotation.y += 0.007;

	
			if (video != null) {
				if (video.readyState === video.HAVE_ENOUGH_DATA) {
					if (texture)
						texture.needsUpdate = true;
				}
			}

      if (mixer != null) {
        var delta = clock.getDelta();
        mixer.update(delta);
      }
      

			// var position = new THREE.Vector3();
			// position.setFromMatrixPosition(cube.matrixWorld);
			//  descriptionElement.innerText= position.x + ',' + position.y + ',' + position.z;
			renderer.render(scene, camera);
			requestAnimationFrame(animate);

		};
animate();
    }

    function onWindowResize() {

      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();

      renderer.setSize(window.innerWidth, window.innerHeight);

    }


    function initAgora(channelName) {

      channelName = document.getElementById("myInput").value;
      client.init(agoraAppId, () => {
        console.log('AgoraRTC client initialized');
        joinChannel(); // join channel upon successfull init
      }, function (err) {
        console.log('[ERROR] : AgoraRTC client init failed', err);
      });

    }


    function joinChannel() {
      //alert(name);
      // set the role
      fetch("https://livear.herokuapp.com/rte/" + channelName + "/audience/uid/0/86400").then(function (response) {
        return response.json();
      }).then(function (data) {
        //  alert(token);

        client.setClientRole('audience', () => {
          console.log('Client role set to audience');
        }, (e) => {
          console.log('setClientRole failed', e);
        });


        client.join(data.rtcToken, channelName, 0, (uid) => {
          console.log('User ' + uid + ' join channel successfully');
        }, function (err) {
          console.log('[ERROR] : join channel failed', err);
        });

      }).catch(function () {
      });

    }

    function leaveChannel() {
      client.leave(() => {

        console.log('client leaves channel');
      }, (err) => {
        console.log('client leave failed ', err); //error handling
      });
    }

    // Agora RTM
    // setu the RTM clit and channel


    function createBroadcaster(streamId) {
      // create video element
      video = document.getElementById('video');
      video.setAttribute('webkit-playsinline', 'webkit-playsinline');
      video.setAttribute('playsinline', 'playsinline');
      video.setAttribute('poster', '/imgs/no-video.jpg');
      texture = new THREE.VideoTexture(video);
      texture.minFilter = THREE.LinearFilter;
      texture.magFilter = THREE.LinearFilter;
      texture.format = THREE.RGBFormat;
      texture.flipY = true;

			var geometry = new THREE.PlaneBufferGeometry(20, 10);

      const vertexShader = document.getElementById("vertexShader").textContent;
      const fragmentShader = document.getElementById("fragmentShader").textContent;

      material = new THREE.ShaderMaterial({
        transparent: true,
        uniforms: {
          map: { value: texture },
          keyColor: { value: [0.0, 1.0, 0.0] },
          similarity: { value: 0.74 },
          smoothness: { value: 0.0 }
        },
        vertexShader: vertexShader,
        fragmentShader: fragmentShader
      });
      material.color = new THREE.Color();
      material.metalness = 0;
      mesh = new THREE.Mesh(geometry, material);
      scene.add(mesh);

      //ads

      if (Broadcaster.objecturl != null) {
        //setAds3DModel();
      }
    }

    function connectStreamToVideo(agoraStream, video) {
      video.srcObject = agoraStream.stream;// add video stream to video element as source
      video.onloadedmetadata = () => {
        // ready to play video
        video.play();
        mesh.position.set(0.0, 1.5, 0.0);
        isset = 1;
        if (ads != null) {
          var position = new THREE.Vector3();
          position.getPositionFromMatrix(mesh.matrixWorld);
          ads.position.set(-0.10 + position.x, position.y, position.z);
        }
      }
    }


    function setAds3DModel(link) {
      loadingBar.visible = true;

      const loader = new GLTFLoader();
      const self = this;
      // Load a glTF resource
      loader.load(
        // resource URL
        link,
        // called when the resource is loaded
        function (gltf) {


          scene.add(gltf.scene);

          chair = gltf.scene;

          chair.traverse((node) => {
            // search the mesh's children for the face-geo
            if (node.isMesh && node.name == 'face-geo') {
              // create video texture from video element
              var texture = new THREE.TextureLoader().load("112097.jpg");
              texture.minFilter = THREE.LinearFilter;
              texture.magFilter = THREE.LinearFilter;
              texture.flipY = false;
              node.material.map = texture;
              node.material.color = new THREE.Color();
              node.material.metalness = 0;
            }
          });

          chair.visible = false;
          loadingBar.visible = false;
            chair.position.set(0.0, 2.0, 0.0);
            chair.scale.set(4.0, 4.0, 4.0);

                mixer= new THREE.AnimationMixer(chair);
                const clips= gltf.animations; // second animation;
            //  const clip=THREE.AnimationClip.findByName(clips,'ArmatureAction');
            //  console.log(clip);
            //  mixer.clipAction( clip).play();
            if(clips!=null){
              clips.forEach( function ( clip ) {
  mixer.clipAction( clip ).play();
} );
}
         // renderer.setAnimationLoop(render.bind(this));

          
          chair.visible = true;
        },
        // called while loading is progressing
        function (xhr) {

          loadingBar.progress = (xhr.loaded / xhr.total);

        },
        // called when loading has errors
        function (error) {

          console.log(error);
          loadingBar.visible = false;


        }
      );




    }
    function InitClient() {
      if (client != null) {
        // connect remote streams
        client.on('stream-added', (evt) => {
          const stream = evt.stream;
          const streamId = stream.getId();
          console.log('New stream added: ' + streamId);
          console.log('Subscribing to remote stream:' + streamId);
          // Subscribe to the stream.
          client.subscribe(stream, (err) => {
            console.log('[ERROR] : subscribe stream failed', err);
          });

          streamCount++;
          createBroadcaster(streamId);  // create 3d broadcaster
        });
        client.on('stream-removed', (evt) => {
          const stream = evt.stream;
          stream.stop(); // stop the stream
          stream.close(); // clean up and close the camera stream
          console.log('Remote stream is removed ' + stream.getId());
        });

        client.on('stream-subscribed', (evt) => {
          const remoteStream = evt.stream;
          const remoteId = remoteStream.getId();
          console.log('Successfully subscribed to remote stream: ' + remoteStream.getId());

          // get the designated video element and add the stream as its video source
          var video = document.getElementById('video');
          connectStreamToVideo(remoteStream, video);

        });

        // remove the remote-container when a user leaves the channel
        client.on('peer-leave', (evt) => {
          console.log('Remote stream has left the channel: ' + evt.uid);
          evt.stream.stop(); // stop the stream
          const remoteId = evt.stream.getId();
          document.getElementById(remoteId).remove();
          document.getElementById('video');
          streamCount--;
        });

        // show mute icon whenever a remote has muted their mic
        client.on('mute-audio', (evt) => {
          console.log('mute-audio for: ' + evt.uid);
        });

        client.on('unmute-audio', (evt) => {
          console.log('unmute-audio for: ' + evt.uid);
        });

        // show user icon whenever a remote has disabled their video
        client.on('mute-video', (evt) => {
          console.log('mute-video for: ' + evt.uid);
        });

        client.on('unmute-video', (evt) => {
          console.log('unmute-video for: ' + evt.uid);
        });
      }

      if (rtmClient != null) {
        rtmClient.on('ConnectionStateChange', (newState, reason) => {
          console.log('on connection state changed to ' + newState + ' reason: ' + reason);
        });
      }

      // event listener for receiving a channel message


    }
    //

    function Timer() {
      leaveChannel();
      //   setTimeout("Timer()",1000);
      // joinChannel(channelName);
    }

    function dragObject() {
			// If 'holding' an object, move the object
			if (draggableObject) {
				raycaster.setFromCamera(moveMouse, camera);
				// `found` is the metadata of the objects, not the objetcs themsevles
				const found = raycaster.intersectObjects(scene.children);
				if (found.length) {
					for (let obj3d of found) {
						if (!obj3d.object.isDraggablee) {
							draggableObject.position.x = obj3d.point.x;
							draggableObject.position.z = obj3d.point.z;
							importedObjectposition.position.x = obj3d.point.x;
							importedObjectposition.position.y = 0.0;
							importedObjectposition.position.z = obj3d.point.z;

							break;
						}
					}
				}
			}
		}

		window.addEventListener("click", (event) => {
			// If 'holding' object on-click, set container to <undefined> to 'drop' the object.
			if (draggableObject) {
				draggableObject = undefined;
				return;
			}

			// If NOT 'holding' object on-click, set container to <object> to 'pickup' the object.
			clickMouse.x = (event.clientX / window.innerWidth) * 2 - 1;
			clickMouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
			raycaster.setFromCamera(clickMouse, camera);
			const found = raycaster.intersectObjects(scene.children, true);
			if (found.length && found[0].object.isDraggable) {
				draggableObject = found[0].object;
				importedObjectposition = found[0].object;
			}
		});

		// Constantly updates the mouse location for use in `dragObject()`
		window.addEventListener("mousemove", (event) => {
			dragObject(); // Updates the object's postion every time the mouse moves
			moveMouse.x = (event.clientX / window.innerWidth) * 2 - 1;
			moveMouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
		});

  

   

    

  </script>
  <script type="module" src="/js/index_greenscreen.js"></script>
  <script src="/js/main.min.js"></script>
  <script type="module">
    import { loadAllBroadcast, inputValue, loadAds } from '/js/index_greenscreen.js';
    loadAllBroadcast();


  </script>
</body>

<!-- for broadcast user use: https://digitallysavvy.github.io/group-video-chat -->

</html>