<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - multiple elements</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
		<style>
			* {
				box-sizing: border-box;
				-moz-box-sizing: border-box;
			}

			body {
				background-color: #fff;
				color: #444;
			}

			a {
				color: #08f;
			}

			#content {
				position: absolute;
				top: 0; width: 100%;
				z-index: 1;
				padding: 3em 0 0 0;
			}

			#c {
				position: absolute;
				left: 0;
				width: 100%;
				height: 100%;
			}

			.list-item {
				display: inline-block;
				margin: 1em;
				padding: 1em;
				box-shadow: 1px 2px 4px 0px rgba(0,0,0,0.25);
			}

			.list-item > div:nth-child(1) {
				width: 200px;
				height: 200px;
			}

			.list-item > div:nth-child(2) {
				color: #888;
				font-family: sans-serif;
				font-size: large;
				width: 200px;
				margin-top: 0.5em;
			}
		</style>
	</head>
	<body>
		<header hidden class="mdl-layout__header mdl-color-text--white mdl-color--light-blue-700">
			<div class="mdl-cell mdl-cell--12-col mdl-cell--12-col-tablet mdl-grid">
			  <div class="mdl-layout__header-row mdl-cell mdl-cell--12-col mdl-cell--12-col-tablet mdl-cell--12-col-desktop">
				<h3><i class="material-icons"></i>Ads Manager</h3>
			  </div>
			  <div id="user-container">
				<div hidden id="user-pic"></div>
				<div hidden id="user-name"></div>
				<button hidden id="sign-out" class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-color-text--white">
				  Sign-out
				</button>
				<button hidden id="sign-in" class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-color-text--white">
				  <i class="material-icons"></i>Sign-in
				</button>
			  </div>
			</div>
		  </header>

		  <div id="messages-card-container" class="mdl-cell mdl-cell--12-col mdl-grid">
			<h2>Diffuse Image or 3D Models Ads</h2>
		
			<!-- Messages container -->
			<div id="messages-card" class="mdl-card mdl-shadow--2dp mdl-cell mdl-cell--12-col mdl-cell--6-col-tablet mdl-cell--6-col-desktop">
			  <div class="mdl-card__supporting-text mdl-color-text--grey-600">
				<div id="messages">
				</div>
				<form id="message-form" action="#">
				  <div class="mdl-textfield mdl-js-textfield mdl-textfield--floating-label">
					<input class="mdl-textfield__input" type="text" id="message" autocomplete="off">
					<label class="mdl-textfield__label" for="message">Message...</label>
				  </div>
				  <button id="submit" disabled type="submit" class="mdl-button mdl-js-button mdl-button--raised mdl-js-ripple-effect">
					Send
				  </button>
				</form>
				<form id="image-form" action="#">
				  <input id="mediaCapture" type="file" accept="image/*, .glb">
				<!--   <input id="mediaCapture" type="file" accept="image/*" capture="camera">-->
				  <button id="submitImage" title="Add an image" class="mdl-button mdl-js-button mdl-button--raised mdl-js-ripple-effect mdl-color--amber-400 mdl-color-text--white">
					<i class="material-icons">image</i>
				  </button>
				</form>
			  </div>
			</div>
		
			<div id="must-signin-snackbar" class="mdl-js-snackbar mdl-snackbar">
			  <div class="mdl-snackbar__text"></div>
			  <button class="mdl-snackbar__action" type="button"></button>
			</div>
		
		  </div>

		<canvas id="c"></canvas>

		<div id="content">
		</div>

		<!-- Import maps polyfill -->
		<!-- Remove this when import maps will be widely supported -->
		<script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.module.js"
				}
			}
		</script>

		<script type="module">

import * as THREE from './jsm/three.module.js';
			import { OrbitControls } from './jsm/OrbitControls.js';
    import {Ads, loadAds} from './js/index_ads.js';
	import { GLTFLoader } from './jsm/GLTFLoader.js';


			let canvas, renderer;

			const scenes = [];

			init();
			animate();

			document.addEventListener("models", function(e) {
 // alert(e.detail);
Ads.link=e.detail;
if (Ads.link.imageUrl!=null && Ads.link.imageUrl.includes("glb")){
  setAds3DModel(Ads.link);
}
});

			function init() {
                loadAds();
				canvas = document.getElementById( "c" );

				const geometries = [
					new THREE.BoxGeometry( 1, 1, 1 ),
					new THREE.SphereGeometry( 0.5, 12, 8 ),
					new THREE.DodecahedronGeometry( 0.5 ),
					new THREE.CylinderGeometry( 0.5, 0.5, 1, 12 )
				];


				renderer = new THREE.WebGLRenderer( { canvas: canvas, antialias: true } );
				renderer.setClearColor( 0xffffff, 1 );
				renderer.setPixelRatio( window.devicePixelRatio );

				fetch('https://8gb9jnvhx7.execute-api.eu-west-1.amazonaws.com/stage1/Get_3DModelLibrary', {
          method: 'POST',
          body: JSON.stringify({
			request:"Library"
          })
      })
      .then(response => response.json())
      .then(data => {
          console.log("objectsS3",data.objects);
		  for(var i =0;i<=data.objects.length;i++){
			setAds3DModel(data.objects[i]);
		  }
      })
      .catch(error => {
          console.error(error);
      });
			}

			function setAds3DModel(link){
    const loader = new GLTFLoader( );
        const self = this;
        // Load a glTF resource
        loader.load(
            // resource URL
          //  link.imageUrl + '&' + new Date().getTime(),
		  link.Key,
            // called when the resource is loaded
            function ( gltf ) {

				const content = document.getElementById( 'content' );


				const scene = new THREE.Scene();

// make a list item
const element = document.createElement( 'div' );
element.className = 'list-item';

const sceneElement = document.createElement( 'div' );
element.appendChild( sceneElement );

const descriptionElement = document.createElement( 'div' );
descriptionElement.innerText = 'Scene ' + ( link.name + 1 );
element.appendChild( descriptionElement );

// the element that represents the area we want to render the scene
scene.userData.element = sceneElement;
content.appendChild( element );

const camera = new THREE.PerspectiveCamera( 50, 1, 1, 10 );
camera.position.z = 2;
scene.userData.camera = camera;

const controls = new OrbitControls( scene.userData.camera, scene.userData.element );
controls.minDistance = 2;
controls.maxDistance = 7;
controls.enablePan = false;
controls.enableZoom = true;
scene.userData.controls = controls;

gltf.scene.scale.set(1.0,1.0,1.0);
scene.add( gltf.scene );

scene.add( new THREE.HemisphereLight( 0xaaaaaa, 0x444444 ) );

const light = new THREE.DirectionalLight( 0xffffff, 0.5 );
light.position.set( 1, 1, 1 );
scene.add( light );


scenes.push( scene );


            },
            // called while loading is progressing
            function ( xhr ) {

                
            },
            // called when loading has errors
            function ( error ) {

                console.log( error );


            }
        );

  


}


			function updateSize() {

				const width = canvas.clientWidth;
				const height = canvas.clientHeight;

				if ( canvas.width !== width || canvas.height !== height ) {

					renderer.setSize( width, height, false );

				}

			}

			function animate() {

				render();
				requestAnimationFrame( animate );

			}

			function render() {

				updateSize();

				canvas.style.transform = `translateY(${window.scrollY}px)`;

				renderer.setClearColor( 0xffffff );
				renderer.setScissorTest( false );
				renderer.clear();

				renderer.setClearColor( 0xe0e0e0 );
				renderer.setScissorTest( true );

				scenes.forEach( function ( scene ) {

					// so something moves
					scene.children[ 0 ].rotation.y = Date.now() * 0.001;

					// get the element that is a place holder for where we want to
					// draw the scene
					const element = scene.userData.element;

					// get its position relative to the page's viewport
					const rect = element.getBoundingClientRect();

					// check if it's offscreen. If so skip it
					if ( rect.bottom < 0 || rect.top > renderer.domElement.clientHeight ||
						 rect.right < 0 || rect.left > renderer.domElement.clientWidth ) {

						return; // it's off screen

					}

					// set the viewport
					const width = rect.right - rect.left;
					const height = rect.bottom - rect.top;
					const left = rect.left;
					const bottom = renderer.domElement.clientHeight - rect.bottom;

					renderer.setViewport( left, bottom, width, height );
					renderer.setScissor( left, bottom, width, height );

					const camera = scene.userData.camera;

					//camera.aspect = width / height; // not changing in this example
					//camera.updateProjectionMatrix();

					//scene.userData.controls.update();

					renderer.render( scene, camera );

				} );

			}

		</script>
<script type="module" src="/js/index_ads.js"></script>

	</body>
</html>

