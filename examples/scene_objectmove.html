<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>My first three.js app</title>
    <style>
        body {
            margin: 0;
        }
    </style>
</head>

<body>
  <header hidden class="mdl-layout__header mdl-color-text--white mdl-color--light-blue-700">
    <div class="mdl-cell mdl-cell--12-col mdl-cell--12-col-tablet mdl-grid">
      <div class="mdl-layout__header-row mdl-cell mdl-cell--12-col mdl-cell--12-col-tablet mdl-cell--12-col-desktop">
      <h3><i class="material-icons"></i>Ads Manager</h3>
      </div>
      <div id="user-container">
      <div hidden id="user-pic"></div>
      <div hidden id="user-name"></div>
      <button hidden id="sign-out" class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-color-text--white">
        Sign-out
      </button>
      <button hidden id="sign-in" class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-color-text--white">
        <i class="material-icons"></i>Sign-in
      </button>
      </div>
    </div>
    </header>

    <div id="messages-card-container" class="mdl-cell mdl-cell--12-col mdl-grid">
    <h2>Diffuse Image or 3D Models Ads</h2>
  
    <!-- Messages container -->
    <div id="messages-card" class="mdl-card mdl-shadow--2dp mdl-cell mdl-cell--12-col mdl-cell--6-col-tablet mdl-cell--6-col-desktop">
      <div class="mdl-card__supporting-text mdl-color-text--grey-600">
      <div id="messages">
      </div>
      <form id="message-form" action="#">
        <div class="mdl-textfield mdl-js-textfield mdl-textfield--floating-label">
        <input class="mdl-textfield__input" type="text" id="message" autocomplete="off">
        <label class="mdl-textfield__label" for="message">Message...</label>
        </div>
        <button id="submit" disabled type="submit" class="mdl-button mdl-js-button mdl-button--raised mdl-js-ripple-effect">
        Send
        </button>
      </form>
      <form id="image-form" action="#">
        <input id="mediaCapture" type="file" accept="image/*, .glb">
      <!--   <input id="mediaCapture" type="file" accept="image/*" capture="camera">-->
        <button id="submitImage" title="Add an image" class="mdl-button mdl-js-button mdl-button--raised mdl-js-ripple-effect mdl-color--amber-400 mdl-color-text--white">
        <i class="material-icons">image</i>
        </button>
      </form>
      </div>
    </div>
  
    <div id="must-signin-snackbar" class="mdl-js-snackbar mdl-snackbar">
      <div class="mdl-snackbar__text"></div>
      <button class="mdl-snackbar__action" type="button"></button>
    </div>
  
    </div>
  <div id="content">
  </div>

  
    <script src="https://threejs.org/build/three.js"></script>
    <script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>
		<script type="module">
        
        import {Ads, loadAds} from './js/index_ads.js';
        import { GLTFLoader } from './jsm/GLTFLoader.js';

        let controls, clickMouse,
  moveMouse,
  raycaster,
  draggableObject;
    var descriptionElement;

    document.addEventListener("models", function(e) {
 // alert(e.detail);
Ads.link=e.detail;
if (Ads.link.imageUrl!=null && Ads.link.imageUrl.includes("glb")){
  setAds3DModel(Ads.link);
}
});

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 5;

        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);


        const planeGeometry = new THREE.PlaneBufferGeometry(50, 50, 8, 8);
        const planeMaterial = new THREE.MeshPhongMaterial({ color: 0xcccccc });
        const plane = new THREE.Mesh(planeGeometry, planeMaterial);
        plane.rotateX(-Math.PI / 2);
        plane.position.y = -3;
        plane.receiveShadow = true;
        plane.isDraggable = false;
        scene.add(plane);

        const content = document.getElementById( 'content' );
         descriptionElement = document.createElement( 'div' );
descriptionElement.innerText = "test";
content.appendChild( descriptionElement );

        const geometry = new THREE.BoxGeometry(2, 2, 2);
        const material = new THREE.MeshPhongMaterial({ color: 0xff00ff });
        const cube = new THREE.Mesh(geometry, material);
        cube.castShadow = true; //default is false
        cube.isDraggable = true;
        scene.add(cube);

        const geo =  new THREE.SphereGeometry( 0.5, 12, 8 );
        const mat = new THREE.MeshPhongMaterial({ color: 0xff00ff });
        const sphere = new THREE.Mesh(geo, mat);
        sphere.castShadow = true; //default is false
        sphere.isDraggable = true;
        scene.add(sphere);
        // CAMERA MOVEMENT CONTROLS
  controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.update();

  raycaster = new THREE.Raycaster();
  clickMouse = new THREE.Vector2();
  moveMouse = new THREE.Vector2();

        const dirLight1 = new THREE.DirectionalLight(0xffffff);
        dirLight1.position.set(0, 2, 0);
        dirLight1.castShadow = true;
        scene.add(dirLight1);


        const ambientLight = new THREE.AmbientLight(0x444444);
        scene.add(ambientLight);


     
        const animate = function () {
            controls.update();
            requestAnimationFrame(animate);

            cube.rotation.x += 0.01;
            cube.rotation.y += 0.007;

        var position = new THREE.Vector3();
        position.setFromMatrixPosition(cube.matrixWorld);
        descriptionElement.innerText= position.x + ',' + position.y + ',' + position.z;
            renderer.render(scene, camera);
        };
        animate();
        loadAds();

        function setAds3DModel(link){
    const loader = new GLTFLoader( );
        const self = this;
        // Load a glTF resource
        loader.load(
            // resource URL
            link.imageUrl + '&' + new Date().getTime(),
            // called when the resource is loaded
            function ( gltf ) {

	


scene.add( gltf.scene );
gltf.scene.scale.set(4.0,4.0,4.0);
gltf.scene.position.set( 0, 0, 0 );

gltf.scene.castShadow = true; //default is false
gltf.scene.isDraggable = true;
scene.add( new THREE.HemisphereLight( 0xaaaaaa, 0x444444 ) );

const light = new THREE.DirectionalLight( 0xffffff, 0.5 );
light.position.set( 1, 1, 1 );
scene.add( light );


            },
            // called while loading is progressing
            function ( xhr ) {

                
            },
            // called when loading has errors
            function ( error ) {

                console.log( error );


            }
        );

  


}

        function dragObject() {
  // If 'holding' an object, move the object
  if (draggableObject) {
    raycaster.setFromCamera(moveMouse, camera);
    // `found` is the metadata of the objects, not the objetcs themsevles
    const found = raycaster.intersectObjects(scene.children);
    if (found.length) {
      for (let obj3d of found) {
        if (!obj3d.object.isDraggablee) {
          draggableObject.position.x = obj3d.point.x;
          draggableObject.position.z = obj3d.point.z;
          break;
        }
      }
    }
  }
}

window.addEventListener("click", (event) => {
  // If 'holding' object on-click, set container to <undefined> to 'drop' the object.
  if (draggableObject) {
    draggableObject = undefined;
    return;
  }

  // If NOT 'holding' object on-click, set container to <object> to 'pickup' the object.
  clickMouse.x = (event.clientX / window.innerWidth) * 2 - 1;
  clickMouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
  raycaster.setFromCamera(clickMouse, camera);
  const found = raycaster.intersectObjects(scene.children, true);
  if (found.length && found[0].object.isDraggable) {
    draggableObject = found[0].object;
  }
});

// Constantly updates the mouse location for use in `dragObject()`
window.addEventListener("mousemove", (event) => {
  dragObject(); // Updates the object's postion every time the mouse moves
  moveMouse.x = (event.clientX / window.innerWidth) * 2 - 1;
  moveMouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
});
    </script>
</body>

</html>